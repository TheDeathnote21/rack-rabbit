#!/usr/bin/env ruby
# encoding: utf-8
#
# Make requests to a RackRabbit server.
#

#==============================================================================
# PARSE COMMAND LINE OPTIONS
#==============================================================================

require 'optparse'

action  = :run
options = { :rabbit => {} }

summary          = "Make requests to rabbitMQ consumer processes hosted by a RackRabbit server."
usage            = "Usage:  rr [options] [METHOD] [PATH] [BODY]"
banner           = "#{summary}\n\n#{usage}"
routing_key_help = "the routing key used to publish the message (e.g. a queue name)"
host_help        = "the rabbitMQ broker IP address (default: 127.0.0.1)"
port_help        = "the rabbitMQ broker port (default: 5672)"
method_help      = "specify the method used to publish the message (default: GET)"
path_help        = "specify the path of the message (default '')"
body_help        = "specify the body of the message (default '')"
include_help     = "specify an additional $LOAD_PATH (may be used more than once)"
debug_help       = "set $DEBUG to true"
warn_help        = "enable warnings"

op = OptionParser.new
op.banner = banner

op.separator ""
op.separator "RackRabbit options:"
op.on(      "--host HOST",     host_help)        { |value| options[:rabbit][:host] = value                      }
op.on(      "--port PORT",     port_help)        { |value| options[:rabbit][:port] = value                      }
op.on("-r", "--route ROUTE",   routing_key_help) { |value| options[:routing_key]   = value                      }
op.on("-m", "--method METHOD", method_help)      { |value| options[:method]        = value.to_s.upcase.to_sym   }
op.on("-p", "--path PATH",     path_help)        { |value| options[:path]          = value                      }
op.on("-b", "--body BODY",     body_help)        { |value| options[:body]          = value                      }

op.separator ""
op.separator "Ruby options:"
op.on("-I", "--include PATH", include_help) { |value| $LOAD_PATH.unshift(*value.split(":")) }
op.on(      "--debug",        debug_help)   { $DEBUG = true }
op.on(      "--warn",         warn_help)    { $-w = true    }

op.separator ""
op.separator "Common options:"
op.on("-h", "--help")    { action = :help    }
op.on("-v", "--version") { action = :version }

op.separator ""
op.parse!(ARGV)

if options[:method].nil?
  if options[:method] = [:GET, :POST, :PUT, :DELETE, :ENQUEUE].find{|m| m == ARGV[0].to_s.upcase.to_sym }
    ARGV.delete_at(0)
  else
    options[:method] = :GET
  end
end

options[:path] ||= ARGV.shift
options[:body] ||= ARGV.shift

#==============================================================================
# EXECUTE script (within an EM reactor if necessary)
#==============================================================================

require 'rack-rabbit/client'

case action
when :help    then puts op.to_s
when :version then puts RackRabbit::VERSION
else
  case options[:method]
  when :GET     then puts RackRabbit::Client.get(options[:path], options)
  when :POST    then puts RackRabbit::Client.post(options[:path], options[:body], options)
  when :PUT     then puts RackRabbit::Client.put(options[:path], options[:body], options)
  when :DELETE  then puts RackRabbit::Client.delete(options[:path], options)
  when :ENQUEUE then puts RackRabbit::Client.enqueue(options)
  when :PUBLISH then puts RackRabbit::Client.publish(options)
  else
    raise ArgumentError, "unknown method #{options[:method]}"
  end
end

#==============================================================================
